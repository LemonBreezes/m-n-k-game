#+title: A Python Tic Tac Toe game

* Outline
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 14:52]
:END:

#+BEGIN_SRC python :noweb yes :tangle main.py :exports none
"""This is a Python Tic Tac Toe game"""

# imports
import sys
<<tictactoe-main-imports>>

# constants
<<tictactoe-constants>>

# exception classes

# interface functions

# classes
<<TicTacToeBoard-defn>>

<<TicTacToeGame-defn>>

# internal functions & classes
<<tictactoe-main>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC

* Main
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 15:54]
:END:

#+name: tictactoe-main
#+begin_src python
def main():
    game = TicTacToeGame(board_size, num_players, winning_row_length)
    game.start()
    return 0
#+end_src

* Constants
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 19:30]
:END:

#+name: tictactoe-constants
#+begin_src python
board_size = 3
num_players = 1
winning_row_length = 3
#+end_src

* Define the ~TicTacToeGame~ class
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 16:20]
:END:

#+name: TicTacToeGame-defn
#+begin_src python
class TicTacToeGame(object):
    def __init__(self, size, num_players, winning_row_length):
        self.board = TicTacToeBoard(size, num_players, winning_row_length)

    def start(self):
        board = self.board
        board.display()
        while True:
            move = [ int(x) for x in input('Make your move: ').split()]
            board.addMark(x=move[0],y=move[1],player=1)
            board.display()
            if (board.getWinner() == 1):
                print('You win!')
                break
#+end_src

** Brainstorming
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:18]
:END:

*** The first step: How do I encode the board's state?
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:23]
:END:

So I need to first figure out how to store the state of the game. The game is a
two-dimensional grid of characters, which I will encode as non-negative integers,
one for each player and one encoding an empty tile.

** [ ] Add a GUI for the game
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 00:04]
:END:

* Define the ~TicTacToeBoard~ class
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:32]
:END:

#+name: TicTacToeBoard-defn
#+begin_src python
class TicTacToeBoard(object):
    def __init__(self, size, num_players, winning_row_length):
        self._size = size
        self._num_players = num_players
        self._winning_row_length = winning_row_length
        self._board = [[0 for i in range(size)] for j in range(size)]
        self._adjacency_matrices = [matrix([[0 for p in range(size**2)]
                                            for q in range(size**2)])
                                    for player in range(self._num_players)]

    def display(self):
        board = '|\n|'.join(['|'.join(map(str, row)) for row in self._board])
        board = '_' * (self._size * 2) + '_\n|' + board
        board = board + '|\n‾' + '‾' * (self._size * 2)
        print(board)

    def _hashCoordinate(self, x, y):
        return x + y*self._size

    def addMark(self, x, y, player):
        x = x - 1
        y = y - 1
        board = self._board
        board[x][y] = player
        for i, j in product(range(-1,2),range(-1,2)):
            if (i == 0 and j == 0):
                continue
            p = self._hashCoordinate(x, y)
            q = self._hashCoordinate(x+i,y+j)
            r = self._hashCoordinate(x-i,y-j)
            # print('player,x,y,i,j,p,q,r are: ' + str(player) + ' '
            #       + str(x) + ' ' + str(y) + ' ' + str(i) + ' ' + str(j) + ' '
            #       + str(p) + ' ' + str(q) + ' ' + str(r))
            if (0 <= x+i < self._size and 0 <= y+j < self._size and board[x+i][y+j] == player):
                if (0 <= x-i < self._size and 0 <= y-j < self._size
                    and board[x-i][y-j] == player):
                    self._adjacency_matrices[player-1][q,p] = 1
                else:
                    self._adjacency_matrices[player-1][p,q] = 1

    def getWinner(self):
        for player in range(self._num_players):
            m = self._adjacency_matrices[player]**(self._winning_row_length - 1)
            # print(m)
            for i, j in product(range(self._size**2), range(self._size**2)):
                if (m[i,j] == 1):
                    return player + 1

    def clear(self):
        self._board = [[0 for i in range(self.size)] for j in range(self.size)]
        self._adjacency_matrices = [matrix([[0 for p in range(self.size**2)]
                                            for q in range(self.size**2)])
                                    for player in range(self._num_players)]
#+end_src

** Brainstorming
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 00:36]
:END:

*** Ideas on storing the board's state
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:41]
:END:

The only operations the board needs to do are display and add a mark. The board
should be both a matrix of integers and an unordered set of sequences of
adjacencies. I can use an array of numbers for the board and a set of numbers
for the sequences of adjacencies.

*** How do I compute the winner?
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 09:10]
:END:

So I just realized a problem with my adjacencies. For a sequence of adjacencies
to realize a winner, they have to form a line, rather than a corner. For this to
happen in a triple means that two adjacencies intersect on a point and the other
two points are not adjacent. Basically, I need to determine if a path is a cycle.

* Create ~unittest~ tests
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 13:48]
:END:

** ~TicTacToeBoard~ tests
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 15:18]
:END:

#+name: unittest-TicTacToeBoard
#+begin_src python
class TestTicTacToeBoard(unittest.TestCase):
    def test_addMark(self):
        board = TicTacToeBoard(3)
        board.addMark(x=1,y=1,player=1)
        self.assertEqual(board._board, [[1, 0, 0], [0, 0, 0], [0, 0, 0]])
        assert array_equal(board._adjacency_matrices,
                           [matrix([[0 for p in range(9)]
                                    for q in range(9)]) for player in range(1)])
        board.addMark(x=1,y=2,player=1)
        self.assertEqual(board._board, [[1, 1, 0], [0, 0, 0], [0, 0, 0]])
        assert array_equal(
            board._adjacency_matrices,
            [matrix([[0, 0, 0, 1, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0]])])
        
    def test_getWinner(self):
        pass
#+end_src

* Write ~run_tests.py~
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 15:16]
:END:

#+begin_src python :noweb yes :tangle run_tests.py :exports none
import sys
import unittest
from main import *
from numpy import array_equal

<<unittest-TicTacToeBoard>>

def main():
    suite = unittest.TestSuite()
    suite.addTests(
        unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__]))
    unittest.TextTestRunner(verbosity=2).run(suite)
    return 0

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+end_src

* Imports
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 15:59]
:END:

#+name: tictactoe-main-imports
#+begin_src python
from itertools import product
from numpy import matrix
#+end_src
