#+title: A Python Tic Tac Toe game

* Outline
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 14:52]
:END:

#+BEGIN_SRC python :noweb yes :tangle main.py :exports none
"""This is a Python Tic Tac Toe game"""

# imports
import sys
<<tictactoe-main-imports>>

# constants

# exception classes

# interface functions

# classes
<<TicTacToeBoard-defn>>

<<TicTacToeGame-defn>>

# internal functions & classes
<<tictactoe-main>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC

* Main
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 15:54]
:END:

#+name: tictactoe-main
#+begin_src python
def main():
    game = TicTacToeGame(3)
    game.start()
    return 0
#+end_src

* Define the ~TicTacToeGame~ class
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 16:20]
:END:

#+name: TicTacToeGame-defn
#+begin_src python
class TicTacToeGame(object):
    def __init__(self, size):
        self.board = TicTacToeBoard(size)

    def start(self):
        board = self.board
        board.display()
        while True:
            move = [ int(x) for x in input('Make your move: ').split()]
            board.addMark(x=move[0],y=move[1],player=1)
            board.display()
            if board.getWinner():
                print('You win!')
#+end_src

** Brainstorming
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:18]
:END:

*** The first step: How do I encode the board's state?
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:23]
:END:

So I need to first figure out how to store the state of the game. The game is a
two-dimensional grid of characters, which I will encode as non-negative integers,
one for each player and one encoding an empty tile.

** [ ] Add a GUI for the game
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 00:04]
:END:

* Define the ~TicTacToeBoard~ class
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:32]
:END:

#+name: TicTacToeBoard-defn
#+begin_src python
class TicTacToeBoard(object):
    def __init__(self, size):
        self.size = size
        self.board = [[0 for i in range(size)] for j in range(size)]
        self.adjacencies = {}

    def display(self):
        board = '|\n|'.join(['|'.join(map(str, row)) for row in self.board])
        board = '_' * (self.size * 2) + '_\n|' + board
        board = board + '|\n‾' + '‾' * (self.size * 2)
        print(board)

    def _hashCoordinate(self, x, y):
        return x + y*self.size

    def addMark(self, x, y, player):
        self.board[x][y] = player
        for i, j in product(range(-1,1),range(-1,1)):
                if (0 < x + i < self.size
                    and 0 < y + j < self.size
                    and self.board[x + i][x + j] == player):
                    self.adjacencies.add(
                        (player, {_hashCoordinate(x, y), _hashCoordinate(x+i,y+j)})
                    )
                    
    def getWinner(self):
        if len(self.adjacencies) < self.size:
            return 0
#+end_src

** Brainstorming
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 00:36]
:END:

*** Ideas on storing the board's state
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 22:41]
:END:

The only operations the board needs to do are display and add a mark. The board
should be both a matrix of integers and an unordered set of sequences of
adjacencies. I can use an array of numbers for the board and a set of numbers
for the sequences of adjacencies.

*** How do I compute the winner?
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 09:10]
:END:

So I just realized a problem with my adjacencies. For a sequence of adjacencies
to realize a winner, they have to form a line, rather than a corner. For this to
happen in a triple means that two adjacencies intersect on a point and the other
two points are not adjacent. Basically, I need to determine if a path is a cycle.

* Create ~unittest~ tests
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 13:48]
:END:

** ~TicTacToeBoard~ tests
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 15:18]
:END:

#+name: unittest-TicTacToeBoard
#+begin_src python
class TestTicTacToeBoard(unittest.TestCase):
    def test_addMark(self):
        board = TicTacToeBoard(3)
        board.addMark(x=1,y=1,player=1)
        self.assertEqual(board._board, [[1, 0, 0], [0, 0, 0], [0, 0, 0]])
        assert array_equal(board._adjacency_matrices, [matrix([[0 for p in range(9)] for q in range(9)]) for player in range(1)])
        board.addMark(x=1,y=2,player=1)
        self.assertEqual(board._board, [[1, 0, 0], [0, 0, 0], [0, 0, 0]])
        assert array_equal(board._adjacency_matrices,
                           [matrix([[1 if p == _hashCoordinate(1,1) and q == _hashCoordinate(1,2)
                                     for p in range(9)] for q in range(9)]) for player in range(1)])
        
    def test_getWinner(self):
        pass
#+end_src

* Write ~run_tests.py~
:PROPERTIES:
:CREATED_TIME: [2021-11-08 Mon 15:16]
:END:

#+begin_src python :noweb yes :tangle run_tests.py :exports none
import sys
import unittest
from main import *
from numpy import array_equal

<<unittest-TicTacToeBoard>>

def main():
    suite = unittest.TestSuite()
    suite.addTests(
        unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__]))
    unittest.TextTestRunner(verbosity=2).run(suite)
    return 0

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+end_src

* Imports
:PROPERTIES:
:CREATED_TIME: [2021-11-07 Sun 15:59]
:END:

#+name: tictactoe-main-imports
#+begin_src python
from itertools import product
from numpy import matrix
#+end_src
